## 코틀린의 철학

코틀린이 자바와의 상호운용성에 초점을 맞춘 실용적이고 간결하며 안전한 언어라고 불리우는 이유는 아래와 같다.

### 실용성
코틀린은 어느 특정 프로그래밍 스타일이나 패러다임을 강요하지 않는다. 코틀린을 처음 배우더라도 자바에 익숙한 사람은
익숙한 프로그래밍 스타일이나 기법을 활용할 수 있다. 뿐만 아니라, 코틀린 언어를 지원하는 IDE는 더 간결한 구조로 바꿀 수 있는 대부분의
코드 패턴을 도구가 자동으로 감ㅈ지해서 수정하라고 제안도 해준다. 이런 자동 수정 안내를 살펴보면서 코틀린 언어ㅢ 특성을 잘 이해하면 자신의 코드에 그런 특성을 적용하는 법을 배울 수 있다.

### 간결성
코틀린은 Getter, Setter, 생성자 파라미터를 필드에 대입하기 위한 로직 등 자바에 존재하는 여러 번거로운 준비 코드를
묵시적으로 제공하기 때문에 코틀린 소스코드는 그런 준비 코드로 인해 지저분 해지는 일이 없다.

또한 컬렉션에서 원소를 찾는 행위와 같은 일반적인 작업을 수행하는 것도 마찬가지로 코틀린의 당야한 표준 라이브러리를 통해
반복적이고 코드를 길어지게 만드는 것들에 대해 라이브러리 함수 호출로 대치할 수 있다.

코틀린은 람다를 지원하기 때문에 작은 코드 블록을 라이브러리 함수에 쉽게 전달할 수 있다.

### 안전성
프로그래밍에서 안전성이란 프로그램에서 발생할 수 있는 오류 중에서 일부 유형의 오류를 프로그램 설계가 원천적으로 방지해준다는 뜻이다.
언어가 안전성을 확보하기 위해서는 결국 컴파일러가 어떻게 프로그램이 작동되어야하는지에 대한 정보를 보다 더 정확하게 제공을 해주어야한다.
하지만, 그렇게 된다면 프로그램에 더 많은 정보를 덧붙혀야 하기 떄문에 생산성이 상대적으로 떨어질 수 있다.
결국, 안전성은 생산성과 트레이드 오프 관계가 성립된다.

코틀린은 타입을 자동으로 추론하여 타입 정보를 지정할 필요가 없을 뿐더러, NPE(Null Pointer Exception)을 실행시점에 오류로 발생하지 않도록
컴파일 시점에 검사를 통해 오류를 더 많이 방지해준다. 코틀린은 null이 될 수 없는 값을 추적하며, 실행 시점에 NPE가 발생핧 수 있는 연산을 사용하는 코드를 금한다.

널의 가능성여부는 오로지 '?' 한글자만 추가하면 된다.

```kotlin
val s: String? = null //널이 될 수 있음
val s2: String = "" //널이 될 수 없음
```

또한 ClassCastException도 컴파일 시점에 방지해준다. 어떤 객체를 다른 타입으로 캐스트하기 전에 타입을 미리 검사하지 않았다면
ClassCastException이 발생할 수도 있다. 하지만 코틀린에서는 타입 검사와 캐스트가 한 연산자에 의해 이루어진다.
어떤 객체의 타입을 검사했고 그 객체가 그 타입에 속한다면 해당 타입의 메서드나 필드 등의 멤버를 별도의 캐스트 없이 사용할 수 있다.

```kotlin
if (value is String) //타입 검사
    println(value.toUpperCase()) //해당 타입의 메서드 사용
```

### 상호운용성
코틀린에게 상호운용성이란 기존 자바에서 사용하던 라이브러리를 그대로 사용할 수 있느냐에 대한 질문일 것이다.
코틀린은 당연히 그럴 수 있다. 자바 클래스의 상속(확장), 인터페이스 구현, 자바 애노테이션 사용등 모두 가능하다.

자바에서 코틀린을 호출할 때, 그냥 평상시 자바 클래스나 메서드를 호출하는 방법과 동일하게 호출할 수 있다.
이에 따라 자바와 코틀린 코드를 프로젝트에서 원하는 대로 섞어 쓸 수 있는 궁극적인 유연성을 발휘할 수도 있다.

코틀린은 자바와 소스코드가 섞여있어도 다중 언어 프로젝트를 완전히 지원하기 때문에 제대로 프로그램을 컴파일 할 수 있다.

- 자바와 코틀린 소스 파일을 자유롭게 내비게이션할 수 있다.
- 여러 언어로 이뤄진 프로젝트를 디버깅하고 서로 다른 언어로 작성된 코드를 언어와 관계없이 한 단계씩 실행할 수 있다.
- 자바 메서드를 리팩토링해도 그 메서드와 관련 있는 코틀린 코드까지 제대로 변경된다. 역으로도 가능하다.

